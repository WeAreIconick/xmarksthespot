<?xml version="1.0"?><artefact xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="artefact.xsd" name="X Marks the Spot" slug="x-marks-the-spot" type="code-package">
  <file name="readme.txt">
    <description>This file contains the readme information for the block. It is used to provide information about the block, its usage, and any other relevant details.</description>
    <content><![CDATA[=== X Marks the Spot ===

Contributors:      iconick
Tags:              block, image, interactive, hotspots, ecommerce
Tested up to:      6.8
Stable tag:        0.1.0
License:           GPLv2 or later
License URI:       https://www.gnu.org/licenses/gpl-2.0.html

Transform static images into engaging, clickable experiences with interactive hotspots.

== Description ==

The X Marks the Spot Block allows you to transform any static image into an engaging, interactive experience. Users can click on specific areas of your images to reveal hidden content, product information, additional media, or any other type of content you want to showcase.

**Key Features:**

* **Visual Hotspot Editor** - Drag and drop hotspots directly on your uploaded images
* **Customizable Indicators** - Choose from pulsing dots, plus signs, custom icons, or numbered badges
* **Flexible Content Types** - Add text, images, videos, product details, forms, or external links
* **Multiple Popup Styles** - Modal overlays, inline expansion, sidebar panels, or lightweight tooltips
* **Mobile Optimized** - Touch-friendly interactions with appropriate sizing
* **Hover Effects** - Visual hints for interactivity with glow, scale, and color changes
* **Responsive Design** - Automatic hotspot repositioning for different screen sizes

**Perfect for:**

* **E-commerce** - Fashion lookbooks, product showcases, room setups with clickable items
* **Real Estate** - Property photos with room details and virtual tour links
* **Education** - Anatomy diagrams, historical photos, technical explanations
* **Tourism** - Destination images, hotel amenities, local attractions
* **Marketing** - Interactive infographics, product demonstrations, storytelling

**Content Types Supported:**

* Product details with pricing and purchase options
* Image galleries and 360° views
* Embedded videos and testimonials
* Detailed descriptions and specifications
* Contact forms and booking widgets
* Social media links and external resources

== Installation ==

1. Upload the plugin files to the `/wp-content/plugins/x-marks-the-spot` directory, or install the plugin through the WordPress plugins screen directly.
2. Activate the plugin through the 'Plugins' screen in WordPress
3. Add the X Marks the Spot block to any post or page
4. Upload your image and start adding hotspots by clicking on the image
5. Customize each hotspot's content, appearance, and behavior

== Frequently Asked Questions ==

= How do I add hotspots to my image? =

After adding the block and uploading an image, simply click anywhere on the image to add a hotspot at that location. You can then drag the hotspot to reposition it precisely.

= Can I customize the appearance of hotspots? =

Yes! You can choose from different indicator styles (dots, plus signs, numbers, custom icons), adjust colors, sizes, and animation effects through the block settings panel.

= What types of content can I add to hotspots? =

Hotspots support rich text content, images, videos, HTML, external links, and even embedded forms. You can create product showcases, educational content, or any interactive experience you can imagine.

= Is the block mobile-friendly? =

Absolutely! The block automatically adjusts hotspot positioning and popup layouts for mobile devices, ensuring a smooth experience across all screen sizes.

= Can I track hotspot interactions? =

While the core block focuses on functionality and user experience, it's designed to be compatible with analytics plugins and custom tracking solutions.

== Screenshots ==

1. Block editor interface showing hotspot placement on an image
2. Frontend view with pulsing hotspot indicators
3. Modal popup displaying hotspot content
4. Mobile responsive layout with touch-optimized hotspots

== Changelog ==

= 0.1.0 =
* Initial release
* Drag and drop hotspot placement
* Multiple content types support
* Responsive design
* Customizable indicators and popups
* Mobile optimization

== Upgrade Notice ==

= 0.1.0 =
Initial release of the X Marks the Spot block.]]></content>
  </file>
  <file name="x-marks-the-spot.php">
    <description>This file contains the block registration code in the form of a single block plugin. Any other plugin related functionality should be added to this file. All block rendering functionality should go to the `render.php` file.</description>
    <content><![CDATA[<?php
/**
 * Plugin Name:       X Marks the Spot
 * Description:       Transform static images into engaging, clickable experiences with interactive hotspots.
 * Version:           0.1.0
 * Requires at least: 6.1
 * Requires PHP:      7.4
 * Author:            WordPress Telex
 * License:           GPLv2 or later
 * License URI:       https://www.gnu.org/licenses/gpl-2.0.html
 * Text Domain:       x-marks-the-spot-block-wp
 *
 * @package XMarksTheSpot
 */

if ( ! defined( 'ABSPATH' ) ) {
	exit; // Exit if accessed directly.
}

/**
 * Registers the block using the metadata loaded from the `block.json` file.
 * Behind the scenes, it registers also all assets so they can be enqueued
 * through the block editor in the corresponding context.
 *
 * @see https://developer.wordpress.org/reference/functions/register_block_type/
 */
function telex_x_marks_the_spot_block_init() {
	register_block_type( __DIR__ . '/build/' );
}
add_action( 'init', 'telex_x_marks_the_spot_block_init' );

/**
 * Enqueue scripts for the interactive functionality
 */
function x_marks_the_spot_enqueue_scripts() {
	if ( has_block( 'telex/block-x-marks-the-spot' ) ) {
		wp_enqueue_script(
			'x-marks-the-spot-frontend',
			plugins_url( 'build/view.js', __FILE__ ),
			array(),
			'0.1.0',
			true
		);
	}
}
add_action( 'wp_enqueue_scripts', 'x_marks_the_spot_enqueue_scripts' );]]></content>
  </file>
  <file name="block.json">
    <description>This file contains metadata about the block including its name, title, category, icon, and other properties. The icon is a WordPress Dashicon name (e.g., "admin-post", "format-aside", "admin-page"). Do not use any icon that's not in the list under any circustamce. These are the only slugs available:
	
	menu menu-alt menu-alt2 menu-alt3 admin-site admin-site-alt admin-site-alt2 admin-site-alt3 dashboard admin-post admin-media admin-links admin-page admin-comments admin-appearance admin-plugins plugins-checked admin-users admin-tools admin-settings admin-network admin-home admin-generic admin-collapse filter admin-customizer admin-multisite welcome-write-blog welcome-add-page welcome-view-site welcome-widgets-menus welcome-comments welcome-learn-more format-aside format-image format-gallery format-video format-status format-quote format-chat format-audio camera camera-alt images-alt images-alt2 video-alt video-alt2 video-alt3 media-archive media-audio media-code media-default media-document media-interactive media-spreadsheet media-text media-video playlist-audio playlist-video controls-play controls-pause controls-forward controls-skipforward controls-back controls-skipback controls-repeat controls-volumeon controls-volumeoff image-crop image-rotate image-rotate-left image-rotate-right image-flip-vertical image-flip-horizontal image-filter undo redo database-add database database-export database-import database-remove database-view align-full-width align-pull-left align-pull-right align-wide block-default button cloud-saved cloud-upload columns cover-image ellipsis embed-audio embed-generic embed-photo embed-post embed-video exit heading html info-outline insert insert-after insert-before remove saved shortcode table-col-after table-col-before table-col-delete table-row-after table-row-before table-row-delete editor-bold editor-italic editor-ul editor-ol editor-ol-rtl editor-quote editor-alignleft editor-aligncenter editor-alignright editor-insertmore editor-spellcheck editor-expand editor-contract editor-kitchensink editor-underline editor-justify editor-textcolor editor-paste-word editor-paste-text editor-removeformatting editor-video editor-customchar editor-outdent editor-indent editor-help editor-strikethrough editor-unlink editor-rtl editor-ltr editor-break editor-code editor-paragraph editor-table align-left align-right align-center align-none lock unlock calendar calendar-alt visibility hidden post-status edit trash sticky external arrow-up arrow-down arrow-right arrow-left arrow-up-alt arrow-down-alt arrow-right-alt arrow-left-alt arrow-up-alt2 arrow-down-alt2 arrow-right-alt2 arrow-left-alt2 sort leftright randomize list-view excerpt-view grid-view move share share-alt share-alt2 rss email email-alt email-alt2 networking amazon facebook facebook-alt google instagram linkedin pinterest podio reddit spotify twitch twitter twitter-alt whatsapp xing youtube hammer art migrate performance universal-access universal-access-alt tickets nametag clipboard heart megaphone schedule tide rest-api code-standards buddicons-activity buddicons-bbpress-logo buddicons-buddypress-logo buddicons-community buddicons-forums buddicons-friends buddicons-groups buddicons-pm buddicons-replies buddicons-topics buddicons-tracking wordpress wordpress-alt pressthis update update-alt screenoptions info cart feedback cloud translation tag category archive tagcloud text bell yes yes-alt no no-alt plus plus-alt plus-alt2 minus dismiss marker star-filled star-half star-empty flag warning location location-alt vault shield shield-alt sos search slides text-page analytics chart-pie chart-bar chart-line chart-area groups businessman businesswoman businessperson id id-alt products awards forms testimonial portfolio book book-alt download upload backup clock lightbulb microphone desktop laptop tablet smartphone phone index-card carrot building store album palmtree tickets-alt money money-alt smiley thumbs-up thumbs-down layout paperclip color-picker edit-large edit-page airplane bank beer calculator car coffee drumstick food fullscreen-alt fullscreen-exit-alt games hourglass open-folder pdf pets printer privacy superhero superhero-alt</description>
    <content><![CDATA[{
    "$schema": "https://schemas.wp.org/trunk/block.json",
    "apiVersion": 3,
    "name": "telex/block-x-marks-the-spot",
    "version": "0.1.0",
    "title": "X Marks the Spot",
    "category": "media",
    "icon": "location",
    "description": "Transform static images into engaging, clickable experiences with interactive hotspots.",
    "example": {
        "attributes": {
            "imageUrl": "https://via.placeholder.com/800x600/cccccc/666666?text=Interactive+Image",
            "hotspots": [
                {
                    "id": 1,
                    "x": 25,
                    "y": 30,
                    "title": "Product Showcase",
                    "content": "Click hotspots to reveal hidden content, product details, or additional media.",
                    "type": "tooltip"
                },
                {
                    "id": 2,
                    "x": 75,
                    "y": 60,
                    "title": "Learn More",
                    "content": "Perfect for e-commerce, education, real estate, and interactive storytelling.",
                    "type": "tooltip"
                }
            ]
        }
    },
    "attributes": {
        "imageId": {
            "type": "number"
        },
        "imageUrl": {
            "type": "string"
        },
        "imageAlt": {
            "type": "string",
            "default": ""
        },
        "hotspots": {
            "type": "array",
            "default": []
        },
        "hotspotStyle": {
            "type": "string",
            "default": "pulse-dot"
        },
        "hotspotColor": {
            "type": "string",
            "default": "#007cba"
        },
        "hotspotSize": {
            "type": "number",
            "default": 20
        },
        "animation": {
            "type": "boolean",
            "default": true
        }
    },
    "supports": {
        "html": false,
        "align": [
            "wide",
            "full"
        ],
        "spacing": {
            "margin": true,
            "padding": true
        }
    },
    "textdomain": "x-marks-the-spot-block-wp",
    "editorScript": "file:./index.js",
    "editorStyle": "file:./index.css",
    "style": "file:./style-index.css",
    "viewScript": "file:./view.js",
    "render": "file:./render.php"
}]]></content>
  </file>
  <file name="index.js">
    <description>This file registers the block, specifies the edit and save functions, and loads the block's metadata</description>
    <content><![CDATA[
  /**
 * Registers a new block provided a unique name and an object defining its behavior.
 *
 * @see https://developer.wordpress.org/block-editor/reference-guides/block-api/block-registration/
 */
import { registerBlockType } from '@wordpress/blocks';

/**
 * Lets webpack process CSS, SASS or SCSS files referenced in JavaScript files.
 * All files containing `style` keyword are bundled together. The code used
 * gets applied both to the front of your site and to the editor.
 *
 * @see https://www.npmjs.com/package/@wordpress/scripts#using-css
 */
import './style.scss';

/**
 * Internal dependencies
 */
import Edit from './edit';
import metadata from './block.json';

/**
 * Every block starts by registering a new block type definition.
 *
 * @see https://developer.wordpress.org/block-editor/reference-guides/block-api/block-registration/
 */
registerBlockType( metadata.name, {
	/**
	 * @see ./edit.js
	 */
	edit: Edit,
} );
	]]></content>
  </file>
  <file name="edit.js">
    <description>This file contains the edit function for the block which is responsible for rendering the block in the editor.</description>
    <content><![CDATA[/**
 * Retrieves the translation of text.
 *
 * @see https://developer.wordpress.org/block-editor/reference-guides/packages/packages-i18n/
 */
import { __ } from '@wordpress/i18n';

/**
 * React hook that is used to mark the block wrapper element.
 * It provides all the necessary props like the class name.
 *
 * @see https://developer.wordpress.org/block-editor/reference-guides/packages/packages-block-editor/#useblockprops
 */
import { 
	useBlockProps,
	MediaUpload,
	MediaUploadCheck,
	InspectorControls
} from '@wordpress/block-editor';

import {
	PanelBody,
	Button,
	SelectControl,
	ColorPicker,
	RangeControl,
	ToggleControl,
	Modal,
	TextControl,
	BaseControl,
	Flex,
	FlexItem,
	TextareaControl,
	__experimentalSpacer as Spacer,
	ExternalLink
} from '@wordpress/components';

import { useState, useRef } from '@wordpress/element';
import { plus, edit, trash } from '@wordpress/icons';

/**
 * Lets webpack process CSS, SASS or SCSS files referenced in JavaScript files.
 * Those files can contain any CSS code that gets applied to the editor.
 *
 * @see https://www.npmjs.com/package/@wordpress/scripts#using-css
 */
import './editor.scss';

/**
 * The edit function describes the structure of your block in the context of the
 * editor. This represents what the editor will render when the block is used.
 *
 * @see https://developer.wordpress.org/block-editor/reference-guides/block-api/block-edit-save/#edit
 *
 * @return {Element} Element to render.
 */
export default function Edit({ attributes, setAttributes }) {
	const {
		imageId,
		imageUrl,
		imageAlt,
		hotspots,
		hotspotStyle,
		hotspotColor,
		hotspotSize,
		animation
	} = attributes;

	const [isModalOpen, setIsModalOpen] = useState(false);
	const [editingHotspot, setEditingHotspot] = useState(null);
	const [tempHotspot, setTempHotspot] = useState({});
	const imageRef = useRef();

	const onSelectImage = (media) => {
		setAttributes({
			imageId: media.id,
			imageUrl: media.url,
			imageAlt: media.alt,
		});
	};

	const onImageClick = (event) => {
		if (!imageUrl) return;

		const rect = event.target.getBoundingClientRect();
		const x = ((event.clientX - rect.left) / rect.width) * 100;
		const y = ((event.clientY - rect.top) / rect.height) * 100;

		const newHotspot = {
			id: Date.now(),
			x: Math.round(x * 100) / 100,
			y: Math.round(y * 100) / 100,
			title: '',
			content: '',
			type: 'tooltip'
		};

		setTempHotspot(newHotspot);
		setEditingHotspot(newHotspot.id);
		setIsModalOpen(true);
	};

	const onEditHotspot = (hotspot) => {
		setTempHotspot({ ...hotspot });
		setEditingHotspot(hotspot.id);
		setIsModalOpen(true);
	};

	const onSaveHotspot = () => {
		const updatedHotspots = editingHotspot && hotspots.find(h => h.id === editingHotspot)
			? hotspots.map(h => h.id === editingHotspot ? tempHotspot : h)
			: [...hotspots, tempHotspot];

		setAttributes({ hotspots: updatedHotspots });
		setIsModalOpen(false);
		setEditingHotspot(null);
		setTempHotspot({});
	};

	const onDeleteHotspot = (id) => {
		setAttributes({
			hotspots: hotspots.filter(h => h.id !== id)
		});
	};

	const onDragHotspot = (id, event) => {
		if (!imageRef.current) return;

		const rect = imageRef.current.getBoundingClientRect();
		const x = ((event.clientX - rect.left) / rect.width) * 100;
		const y = ((event.clientY - rect.top) / rect.height) * 100;

		const updatedHotspots = hotspots.map(hotspot =>
			hotspot.id === id
				? { ...hotspot, x: Math.max(0, Math.min(100, x)), y: Math.max(0, Math.min(100, y)) }
				: hotspot
		);

		setAttributes({ hotspots: updatedHotspots });
	};

	const renderHotspot = (hotspot) => {
		const hotspotStyles = {
			position: 'absolute',
			left: `${hotspot.x}%`,
			top: `${hotspot.y}%`,
			width: `${hotspotSize}px`,
			height: `${hotspotSize}px`,
			backgroundColor: hotspotColor,
			border: '2px solid white',
			borderRadius: hotspotStyle === 'circle' ? '50%' : hotspotStyle === 'square' ? '0' : '50%',
			cursor: 'pointer',
			transform: 'translate(-50%, -50%)',
			display: 'flex',
			alignItems: 'center',
			justifyContent: 'center',
			color: 'white',
			fontSize: '12px',
			fontWeight: 'bold',
			boxShadow: '0 2px 8px rgba(0,0,0,0.3)',
			zIndex: 10
		};

		if (animation && hotspotStyle === 'pulse-dot') {
			hotspotStyles.animation = 'hotspot-pulse 2s infinite';
		}

		return (
			<div
				key={hotspot.id}
				style={hotspotStyles}
				onClick={(e) => {
					e.stopPropagation();
					onEditHotspot(hotspot);
				}}
				onMouseDown={(e) => {
					e.preventDefault();
					const handleMouseMove = (event) => {
						onDragHotspot(hotspot.id, event);
					};
					const handleMouseUp = () => {
						document.removeEventListener('mousemove', handleMouseMove);
						document.removeEventListener('mouseup', handleMouseUp);
					};
					document.addEventListener('mousemove', handleMouseMove);
					document.addEventListener('mouseup', handleMouseUp);
				}}
				title={__('Click to edit, drag to move', 'x-marks-the-spot-block-wp')}
			>
				{hotspotStyle === 'plus' && '+'}
				{hotspotStyle === 'numbered' && hotspots.indexOf(hotspot) + 1}
				{(hotspotStyle === 'pulse-dot' || hotspotStyle === 'circle') && ''}
			</div>
		);
	};

	return (
		<>
			<InspectorControls>
				<PanelBody title={__('Image Settings', 'x-marks-the-spot-block-wp')}>
					<MediaUploadCheck>
						<MediaUpload
							onSelect={onSelectImage}
							allowedTypes={['image']}
							value={imageId}
							render={({ open }) => (
								<Button onClick={open} variant="primary" style={{ marginBottom: '16px' }}>
									{imageUrl ? __('Replace Image', 'x-marks-the-spot-block-wp') : __('Select Image', 'x-marks-the-spot-block-wp')}
								</Button>
							)}
						/>
					</MediaUploadCheck>
					{imageUrl && (
						<TextControl
							label={__('Alt Text', 'x-marks-the-spot-block-wp')}
							value={imageAlt || ''}
							placeholder={__('Describe the image for screen readers', 'x-marks-the-spot-block-wp')}
							onChange={(value) => setAttributes({ imageAlt: value })}
						/>
					)}
				</PanelBody>

				<PanelBody title={__('Hotspot Appearance', 'x-marks-the-spot-block-wp')}>
					<SelectControl
						label={__('Hotspot Style', 'x-marks-the-spot-block-wp')}
						value={hotspotStyle}
						options={[
							{ label: __('Pulsing Dot', 'x-marks-the-spot-block-wp'), value: 'pulse-dot' },
							{ label: __('Plus Sign', 'x-marks-the-spot-block-wp'), value: 'plus' },
							{ label: __('Circle', 'x-marks-the-spot-block-wp'), value: 'circle' },
							{ label: __('Numbered', 'x-marks-the-spot-block-wp'), value: 'numbered' }
						]}
						onChange={(value) => setAttributes({ hotspotStyle: value })}
					/>

					<BaseControl label={__('Hotspot Color', 'x-marks-the-spot-block-wp')}>
						<ColorPicker
							color={hotspotColor}
							onChange={(value) => setAttributes({ hotspotColor: value })}
						/>
					</BaseControl>

					<RangeControl
						label={__('Hotspot Size', 'x-marks-the-spot-block-wp')}
						value={hotspotSize}
						onChange={(value) => setAttributes({ hotspotSize: value })}
						min={10}
						max={50}
					/>

					<ToggleControl
						label={__('Enable Animation', 'x-marks-the-spot-block-wp')}
						checked={animation}
						onChange={(value) => setAttributes({ animation: value })}
					/>
				</PanelBody>

				{hotspots.length > 0 && (
					<PanelBody title={__('Hotspot List', 'x-marks-the-spot-block-wp')}>
						{hotspots.map((hotspot, index) => (
							<Flex key={hotspot.id} justify="space-between" align="center">
								<FlexItem>
									<strong>{hotspot.title || __('Untitled Hotspot', 'x-marks-the-spot-block-wp')}</strong>
								</FlexItem>
								<FlexItem>
									<Button
										icon={edit}
										onClick={() => onEditHotspot(hotspot)}
										size="small"
										label={__('Edit Hotspot', 'x-marks-the-spot-block-wp')}
									/>
									<Button
										icon={trash}
										onClick={() => onDeleteHotspot(hotspot.id)}
										size="small"
										isDestructive
										label={__('Delete Hotspot', 'x-marks-the-spot-block-wp')}
									/>
								</FlexItem>
							</Flex>
						))}
					</PanelBody>
				)}

				<PanelBody title={__('Powered by Telex', 'x-marks-the-spot-block-wp')} initialOpen={false}>
					<p style={{ marginBottom: '12px' }}>
						{__('Telex is basically the J.A.R.V.I.S of WordPress development - an AI that builds blocks so you don\'t have to.', 'x-marks-the-spot-block-wp')}
					</p>
					<ExternalLink href="https://telex.automattic.ai">
						{__('Learn more about Telex', 'x-marks-the-spot-block-wp')}
					</ExternalLink>
				</PanelBody>
			</InspectorControls>

			<div {...useBlockProps()}>
				{!imageUrl ? (
					<div className="interactive-hotspots-placeholder">
						<MediaUploadCheck>
							<MediaUpload
								onSelect={onSelectImage}
								allowedTypes={['image']}
								value={imageId}
								render={({ open }) => (
									<Button onClick={open} variant="primary" icon={plus}>
										{__('Select Image for Hotspots', 'x-marks-the-spot-block-wp')}
									</Button>
								)}
							/>
						</MediaUploadCheck>
						<p>{__('Upload an image and click on it to add interactive hotspots.', 'x-marks-the-spot-block-wp')}</p>
					</div>
				) : (
					<div className="interactive-hotspots-container">
						<div 
							className="interactive-hotspots-image-wrapper"
							onClick={onImageClick}
							style={{ position: 'relative', display: 'inline-block', cursor: 'crosshair' }}
						>
							<img
								ref={imageRef}
								src={imageUrl}
								alt={imageAlt}
								style={{ maxWidth: '100%', height: 'auto', display: 'block' }}
							/>
							{hotspots.map(renderHotspot)}
						</div>
						{hotspots.length === 0 && (
							<p className="interactive-hotspots-help">
								{__('Click anywhere on the image to add a hotspot.', 'x-marks-the-spot-block-wp')}
							</p>
						)}
					</div>
				)}

				{isModalOpen && (
					<Modal
						title={editingHotspot && hotspots.find(h => h.id === editingHotspot) 
							? __('Edit Hotspot', 'x-marks-the-spot-block-wp')
							: __('Add New Hotspot', 'x-marks-the-spot-block-wp')
						}
						onRequestClose={() => setIsModalOpen(false)}
						size="medium"
						className="hotspot-edit-modal"
					>
						<div className="hotspot-modal-content" style={{ padding: '20px' }}>
							<TextControl
								label={__('Hotspot Title', 'x-marks-the-spot-block-wp')}
								value={tempHotspot.title || ''}
								placeholder={__('Enter a short title for this hotspot', 'x-marks-the-spot-block-wp')}
								onChange={(value) => setTempHotspot({ ...tempHotspot, title: value })}
								help={__('A short title for your hotspot', 'x-marks-the-spot-block-wp')}
							/>

							<TextareaControl
								label={__('Hotspot Content', 'x-marks-the-spot-block-wp')}
								value={tempHotspot.content || ''}
								onChange={(value) => setTempHotspot({ ...tempHotspot, content: value })}
								placeholder={__('Enter your hotspot content here. This will appear as a tooltip when users hover over the hotspot...', 'x-marks-the-spot-block-wp')}
								help={__('The content that will appear when users hover over this hotspot. Keep it concise for better tooltip display.', 'x-marks-the-spot-block-wp')}
								rows={6}
								style={{ width: '100%' }}
							/>

							<Spacer />

							<Flex justify="flex-end" gap="2">
								<Button 
									variant="secondary" 
									onClick={() => setIsModalOpen(false)}
								>
									{__('Cancel', 'x-marks-the-spot-block-wp')}
								</Button>
								<Button 
									variant="primary" 
									onClick={onSaveHotspot}
									disabled={!tempHotspot.title}
								>
									{__('Save Hotspot', 'x-marks-the-spot-block-wp')}
								</Button>
							</Flex>
						</div>
					</Modal>
				)}
			</div>
		</>
	);
}]]></content>
  </file>
  <file name="save.js">
    <description>This file contains the save function for the block which is responsible for creating the static result of rendering the block on the client to display the saved result on the front end.</description>
    <content><![CDATA[
  ]]></content>
  </file>
  <file name="style.scss">
    <description>This file contains styles for the block in the front end.</description>
    <content><![CDATA[/**
 * The following styles get applied both on the front of your site
 * and in the editor.
 */

.wp-block-telex-block-x-marks-the-spot {
	position: relative;
	
	.interactive-hotspots-container {
		position: relative;
		
		.interactive-hotspots-image-wrapper {
			position: relative;
			display: inline-block;
			max-width: 100%;
			
			img {
				max-width: 100%;
				height: auto;
				display: block;
			}
		}
		
		.interactive-hotspots-help {
			margin-top: 1rem;
			font-style: italic;
			color: #666;
			text-align: center;
		}
	}
	
	.interactive-hotspots-placeholder {
		text-align: center;
		padding: 2rem;
		border: 2px dashed #ddd;
		border-radius: 8px;
		
		p {
			margin-top: 1rem;
			color: #666;
		}
	}
}

// Hotspot styles with viewport-based scaling
.hotspot {
	position: absolute;
	transform: translate(-50%, -50%);
	z-index: 10;
	cursor: pointer;
	border: 2px solid white;
	box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
	display: flex;
	align-items: center;
	justify-content: center;
	color: white;
	font-weight: bold;
	font-size: clamp(10px, 2.5vw, 14px);
	transition: transform 0.2s ease, box-shadow 0.2s ease;
	
	&:hover {
		transform: translate(-50%, -50%) scale(1.1);
		box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
	}
	
	&.pulse-dot {
		border-radius: 50%;
		animation: hotspot-pulse 2s infinite;
	}
	
	&.circle {
		border-radius: 50%;
	}
	
	&.square {
		border-radius: 0;
	}
	
	&.plus::before {
		content: '+';
	}
}

@keyframes hotspot-pulse {
	0% {
		transform: translate(-50%, -50%) scale(1);
		opacity: 1;
	}
	50% {
		transform: translate(-50%, -50%) scale(1.2);
		opacity: 0.7;
	}
	100% {
		transform: translate(-50%, -50%) scale(1);
		opacity: 1;
	}
}

// Modal styles
.hotspot-modal {
	position: fixed;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	background: rgba(0, 0, 0, 0.8);
	display: flex;
	align-items: center;
	justify-content: center;
	z-index: 10000;
	
	.hotspot-modal-content {
		background: white;
		padding: 2rem;
		border-radius: 8px;
		max-width: 500px;
		max-height: 80vh;
		overflow-y: auto;
		position: relative;
		
		.hotspot-modal-close {
			position: absolute;
			top: 10px;
			right: 10px;
			background: none;
			border: none;
			font-size: 24px;
			cursor: pointer;
			line-height: 1;
			color: #666;
			
			&:hover {
				color: #000;
			}
		}
		
		.hotspot-modal-title {
			margin: 0 0 1rem 0;
			font-size: 1.5rem;
			font-weight: bold;
		}
		
		.hotspot-modal-body {
			line-height: 1.6;
		}
	}
}

// Tooltip styles with closer positioning
.hotspot-tooltip {
	position: absolute;
	background: rgba(0, 0, 0, 0.9);
	color: white;
	padding: 0.5rem 0.75rem;
	border-radius: 4px;
	font-size: clamp(11px, 2vw, 13px);
	line-height: 1.3;
	max-width: clamp(120px, 40vw, 180px);
	z-index: 1000;
	pointer-events: none;
	word-wrap: break-word;
	
	&::after {
		content: '';
		position: absolute;
		left: 50%;
		top: 100%;
		transform: translateX(-50%);
		border: 4px solid transparent;
		border-top-color: rgba(0, 0, 0, 0.9);
	}
	
	&.below {
		&::after {
			top: -8px;
			border-top-color: transparent;
			border-bottom-color: rgba(0, 0, 0, 0.9);
		}
	}
}

// Inline expansion styles
.hotspot-inline-content {
	margin-top: 1rem;
	padding: 1rem;
	background: #f8f9fa;
	border-radius: 8px;
	border-left: 4px solid #007cba;
	
	.hotspot-inline-title {
		font-weight: bold;
		margin-bottom: 0.5rem;
	}
}

// Responsive design with viewport-based scaling
@media (max-width: 768px) {
	.hotspot {
		// Use CSS clamp for responsive sizing based on viewport width
		width: clamp(16px, 4vw, 24px) !important;
		height: clamp(16px, 4vw, 24px) !important;
		font-size: clamp(9px, 2vw, 12px) !important;
		border-width: 1px;
	}
	
	.hotspot-modal .hotspot-modal-content {
		margin: 1rem;
		padding: 1.5rem;
		max-width: none;
	}
	
	.hotspot-tooltip {
		max-width: clamp(100px, 35vw, 140px);
		font-size: clamp(10px, 2vw, 12px);
		padding: 0.4rem 0.6rem;
	}
}

@media (max-width: 480px) {
	.hotspot {
		// Even smaller on very small screens
		width: clamp(14px, 3.5vw, 20px) !important;
		height: clamp(14px, 3.5vw, 20px) !important;
		font-size: clamp(8px, 1.8vw, 11px) !important;
	}
}

@media (min-width: 1200px) {
	.hotspot {
		// Prevent hotspots from getting too large on big screens
		max-width: 28px;
		max-height: 28px;
		font-size: 14px;
	}
}]]></content>
  </file>
  <file name="editor.scss">
    <description>This file contains styles for the block in the editor.</description>
    <content><![CDATA[
  /**
 * The following styles get applied inside the editor only.
 */

.wp-block-telex-block-x-marks-the-spot {
	.interactive-hotspots-container {
		.interactive-hotspots-image-wrapper {
			cursor: crosshair;
			
			&:hover::after {
				content: 'Click to add hotspot';
				position: absolute;
				top: 10px;
				left: 10px;
				background: rgba(0, 0, 0, 0.8);
				color: white;
				padding: 0.25rem 0.5rem;
				border-radius: 4px;
				font-size: 12px;
				pointer-events: none;
				z-index: 20;
			}
		}
	}
}

// Editor-specific hotspot styles
@keyframes hotspot-pulse {
	0% {
		transform: translate(-50%, -50%) scale(1);
		opacity: 1;
	}
	50% {
		transform: translate(-50%, -50%) scale(1.2);
		opacity: 0.7;
	}
	100% {
		transform: translate(-50%, -50%) scale(1);
		opacity: 1;
	}
}

// Modal styles in editor
.hotspot-modal-content {
	.components-base-control {
		margin-bottom: 1rem;
	}
	
	.components-rich-text {
		min-height: 100px;
		border: 1px solid #ddd;
		padding: 0.5rem;
		border-radius: 4px;
	}
}
	]]></content>
  </file>
  <file name="view.js">
    <description>This file contains the view function for the block which is responsible for rendering interactive behaviors of the block on the front end. Ideally using the WordPress interactivity API.</description>
    <content><![CDATA[/**
 * Interactive functionality for X Marks the Spot block
 * Handles tooltips and responsive behavior - optimized for touch screens
 */

document.addEventListener('DOMContentLoaded', function() {
	const hotspotBlocks = document.querySelectorAll('.wp-block-telex-block-x-marks-the-spot');
	
	hotspotBlocks.forEach(initializeHotspotsBlock);
	
	function initializeHotspotsBlock(block) {
		const imageWrapper = block.querySelector('.interactive-hotspots-image-wrapper');
		const image = block.querySelector('img');
		const hotspots = block.querySelectorAll('.hotspot');
		let currentTooltip = null;
		let originalImageSize = null;
		let tooltipTimeout = null;
		let touchStartTime = 0;
		let touchMoved = false;
		let isTouch = false;
		
		// Detect touch device
		const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
		
		// Store original image dimensions once loaded
		if (image.complete) {
			storeOriginalSize();
			updateHotspotPositions();
		} else {
			image.addEventListener('load', function() {
				storeOriginalSize();
				updateHotspotPositions();
			});
		}
		
		function storeOriginalSize() {
			if (!originalImageSize) {
				originalImageSize = {
					width: image.naturalWidth,
					height: image.naturalHeight,
					aspectRatio: image.naturalWidth / image.naturalHeight
				};
			}
		}
		
		function updateHotspotPositions() {
			if (!originalImageSize || !image) return;
			
			const currentImageRect = image.getBoundingClientRect();
			const currentImageWidth = currentImageRect.width;
			const currentImageHeight = currentImageRect.height;
			const currentAspectRatio = currentImageWidth / currentImageHeight;
			
			// Calculate actual displayed image dimensions
			let displayedWidth, displayedHeight;
			let offsetX = 0, offsetY = 0;
			
			if (currentAspectRatio > originalImageSize.aspectRatio) {
				// Image is wider than natural - constrained by height
				displayedHeight = currentImageHeight;
				displayedWidth = displayedHeight * originalImageSize.aspectRatio;
				offsetX = (currentImageWidth - displayedWidth) / 2;
			} else {
				// Image is taller than natural - constrained by width  
				displayedWidth = currentImageWidth;
				displayedHeight = displayedWidth / originalImageSize.aspectRatio;
				offsetY = (currentImageHeight - displayedHeight) / 2;
			}
			
			// Update each hotspot position
			hotspots.forEach(hotspot => {
				const xPercent = parseFloat(hotspot.dataset.x || '50');
				const yPercent = parseFloat(hotspot.dataset.y || '50');
				
				// Calculate position relative to actual displayed image
				const xPos = offsetX + (displayedWidth * xPercent / 100);
				const yPos = offsetY + (displayedHeight * yPercent / 100);
				
				// Convert to percentage of container
				const leftPercent = (xPos / currentImageWidth) * 100;
				const topPercent = (yPos / currentImageHeight) * 100;
				
				hotspot.style.left = leftPercent + '%';
				hotspot.style.top = topPercent + '%';
			});
		}
		
		// Set up event listeners optimized for both touch and mouse
		hotspots.forEach(hotspot => {
			// Touch events for mobile
			hotspot.addEventListener('touchstart', handleTouchStart, { passive: false });
			hotspot.addEventListener('touchmove', handleTouchMove, { passive: false });
			hotspot.addEventListener('touchend', handleTouchEnd, { passive: false });
			hotspot.addEventListener('touchcancel', handleTouchCancel, { passive: false });
			
			// Mouse events for desktop (only if not a touch device)
			if (!isTouchDevice) {
				hotspot.addEventListener('mouseenter', handleTooltipEnter);
				hotspot.addEventListener('mouseleave', handleTooltipLeave);
				hotspot.addEventListener('click', handleClick);
			}
			
			// Keyboard accessibility
			hotspot.addEventListener('keydown', function(e) {
				if (e.key === 'Enter' || e.key === ' ') {
					e.preventDefault();
					handleTooltipClick(e);
				}
			});
			
			// Make hotspots focusable for keyboard navigation
			hotspot.setAttribute('tabindex', '0');
		});
		
		// Handle window resize with debouncing
		let resizeTimeout;
		function handleResize() {
			clearTimeout(resizeTimeout);
			resizeTimeout = setTimeout(() => {
				updateHotspotPositions();
				hideTooltip(); // Hide tooltips on resize
			}, 100);
		}
		
		window.addEventListener('resize', handleResize);
		
		// Also handle orientation change on mobile
		window.addEventListener('orientationchange', function() {
			setTimeout(() => {
				updateHotspotPositions();
				hideTooltip();
			}, 200);
		});
		
		// Touch event handlers
		function handleTouchStart(e) {
			e.preventDefault(); // Prevent default touch behaviors
			isTouch = true;
			touchStartTime = Date.now();
			touchMoved = false;
			
			// Add visual feedback for touch
			const hotspot = e.currentTarget;
			hotspot.style.transform = hotspot.style.transform.replace('scale(1)', '') + ' scale(0.95)';
		}
		
		function handleTouchMove(e) {
			e.preventDefault();
			touchMoved = true;
			
			// Remove visual feedback if user is scrolling
			const hotspot = e.currentTarget;
			hotspot.style.transform = hotspot.style.transform.replace(' scale(0.95)', '');
		}
		
		function handleTouchEnd(e) {
			e.preventDefault();
			const touchDuration = Date.now() - touchStartTime;
			const hotspot = e.currentTarget;
			
			// Remove visual feedback
			hotspot.style.transform = hotspot.style.transform.replace(' scale(0.95)', '');
			
			// Only show tooltip if it was a quick tap without movement
			if (!touchMoved && touchDuration < 500) {
				handleTooltipClick(e);
			}
			
			isTouch = false;
		}
		
		function handleTouchCancel(e) {
			e.preventDefault();
			const hotspot = e.currentTarget;
			hotspot.style.transform = hotspot.style.transform.replace(' scale(0.95)', '');
			isTouch = false;
			touchMoved = true;
		}
		
		// Mouse event handlers (desktop only)
		function handleTooltipEnter(e) {
			if (isTouch) return; // Don't show on touch devices
			
			const hotspot = e.currentTarget;
			const content = hotspot.dataset.content || '';
			
			if (content) {
				showTooltip(hotspot, content);
			}
		}
		
		function handleTooltipLeave(e) {
			if (isTouch) return; // Don't hide on touch devices
			hideTooltip();
		}
		
		function handleClick(e) {
			if (isTouch) return; // Touch events handle this
			e.preventDefault();
			handleTooltipClick(e);
		}
		
		function handleTooltipClick(e) {
			if (e) {
				e.preventDefault();
				e.stopPropagation();
			}
			
			const hotspot = e.currentTarget;
			const content = hotspot.dataset.content || '';
			
			if (content) {
				// Toggle tooltip on touch devices
				if (currentTooltip && currentTooltip.dataset.hotspotId === hotspot.dataset.id) {
					hideTooltip();
					return;
				}
				
				showTooltip(hotspot, content);
				
				// Auto-hide tooltip after delay
				clearTimeout(tooltipTimeout);
				tooltipTimeout = setTimeout(() => {
					hideTooltip();
				}, isTouchDevice ? 4000 : 3000); // Longer on touch devices
			}
		}
		
		function showTooltip(hotspot, content) {
			hideTooltip();
			
			const tooltip = document.createElement('div');
			tooltip.className = 'hotspot-tooltip';
			tooltip.innerHTML = content;
			tooltip.dataset.hotspotId = hotspot.dataset.id;
			
			// Add touch-friendly styles for mobile
			if (isTouchDevice) {
				tooltip.style.fontSize = 'clamp(12px, 3vw, 14px)';
				tooltip.style.padding = '0.75rem';
				tooltip.style.maxWidth = 'clamp(150px, 50vw, 200px)';
				tooltip.style.lineHeight = '1.4';
			}
			
			document.body.appendChild(tooltip);
			currentTooltip = tooltip;
			
			// Position tooltip with better mobile positioning
			const hotspotRect = hotspot.getBoundingClientRect();
			const tooltipRect = tooltip.getBoundingClientRect();
			const viewportWidth = window.innerWidth;
			const viewportHeight = window.innerHeight;
			const scrollY = window.scrollY;
			const scrollX = window.scrollX;
			
			// Center horizontally relative to hotspot
			let left = hotspotRect.left + scrollX + (hotspotRect.width / 2) - (tooltipRect.width / 2);
			// Position above the hotspot with minimal spacing
			let top = hotspotRect.top + scrollY - tooltipRect.height - 5;
			
			// Horizontal boundary checks with more padding on mobile
			const horizontalPadding = isTouchDevice ? 15 : 10;
			if (left < horizontalPadding) {
				left = horizontalPadding;
			} else if (left + tooltipRect.width > viewportWidth - horizontalPadding) {
				left = viewportWidth - tooltipRect.width - horizontalPadding;
			}
			
			// Vertical positioning - prefer above, but use below if necessary
			const verticalPadding = isTouchDevice ? 20 : 10;
			if (top < scrollY + verticalPadding) {
				top = hotspotRect.bottom + scrollY + 5;
				tooltip.classList.add('below');
			}
			
			// Final boundary check for bottom
			if (top + tooltipRect.height > scrollY + viewportHeight - verticalPadding) {
				top = scrollY + viewportHeight - tooltipRect.height - verticalPadding;
			}
			
			tooltip.style.left = left + 'px';
			tooltip.style.top = top + 'px';
			
			// Add fade-in animation
			tooltip.style.opacity = '0';
			tooltip.style.transform = 'translateY(5px) scale(0.95)';
			tooltip.style.transition = 'opacity 0.2s ease, transform 0.2s ease';
			
			setTimeout(() => {
				if (tooltip.parentNode) {
					tooltip.style.opacity = '1';
					tooltip.style.transform = 'translateY(0) scale(1)';
				}
			}, 10);
			
			// Add close button for touch devices
			if (isTouchDevice) {
				const closeButton = document.createElement('button');
				closeButton.innerHTML = '×';
				closeButton.className = 'tooltip-close';
				closeButton.style.cssText = `
					position: absolute;
					top: -5px;
					right: -5px;
					width: 20px;
					height: 20px;
					border-radius: 50%;
					border: none;
					background: rgba(255,255,255,0.9);
					color: #333;
					font-size: 14px;
					font-weight: bold;
					cursor: pointer;
					display: flex;
					align-items: center;
					justify-content: center;
					box-shadow: 0 1px 3px rgba(0,0,0,0.3);
				`;
				
				closeButton.addEventListener('click', function(e) {
					e.preventDefault();
					e.stopPropagation();
					hideTooltip();
				});
				
				tooltip.appendChild(closeButton);
			}
		}
		
		function hideTooltip() {
			clearTimeout(tooltipTimeout);
			if (currentTooltip) {
				currentTooltip.remove();
				currentTooltip = null;
			}
		}
		
		// Hide tooltip when touching/clicking elsewhere
		document.addEventListener('touchstart', function(e) {
			if (!e.target.closest('.hotspot') && !e.target.closest('.hotspot-tooltip')) {
				hideTooltip();
			}
		}, { passive: true });
		
		document.addEventListener('click', function(e) {
			if (!isTouchDevice && !e.target.closest('.hotspot') && !e.target.closest('.hotspot-tooltip')) {
				hideTooltip();
			}
		});
		
		// Hide tooltip on scroll
		window.addEventListener('scroll', hideTooltip, { passive: true });
	}
});]]></content>
  </file>
  <file name="render.php">
    <description>This file contains the render callback function for the block, which is responsible for rendering the block content on the front end. A render function should exist only if the block is dynamic.</description>
    <content><![CDATA[<?php
/**
 * @see https://github.com/WordPress/gutenberg/blob/trunk/docs/reference-guides/block-api/block-metadata.md#render
 */

$image_url = $attributes['imageUrl'] ?? '';
$image_alt = $attributes['imageAlt'] ?? '';
$hotspots = $attributes['hotspots'] ?? [];
$hotspot_style = $attributes['hotspotStyle'] ?? 'pulse-dot';
$hotspot_color = $attributes['hotspotColor'] ?? '#007cba';
$hotspot_size = $attributes['hotspotSize'] ?? 20;
$animation = $attributes['animation'] ?? true;

if (empty($image_url)) {
    return '';
}

$wrapper_attributes = get_block_wrapper_attributes();
?>

<div <?php echo $wrapper_attributes; ?>>
    <div class="interactive-hotspots-container">
        <div class="interactive-hotspots-image-wrapper">
            <img 
                src="<?php echo esc_url($image_url); ?>" 
                alt="<?php echo esc_attr($image_alt); ?>"
                style="max-width: 100%; height: auto; display: block;"
            />
            
            <?php if (!empty($hotspots)): ?>
                <?php foreach ($hotspots as $index => $hotspot): ?>
                    <?php
                    $hotspot_id = $hotspot['id'] ?? $index;
                    $x = $hotspot['x'] ?? 50;
                    $y = $hotspot['y'] ?? 50;
                    $title = $hotspot['title'] ?? '';
                    $content = $hotspot['content'] ?? '';
                    $type = 'tooltip'; // Always use tooltip now
                    $url = $hotspot['url'] ?? '';
                    $link_target = $hotspot['linkTarget'] ?? '_self';
                    
                    $hotspot_classes = ['hotspot', $hotspot_style];
                    if ($animation && $hotspot_style === 'pulse-dot') {
                        $hotspot_classes[] = 'animated';
                    }
                    
                    // Build styles manually with responsive sizing
                    $hotspot_styles = 'position: absolute;';
                    $hotspot_styles .= ' left: ' . esc_attr($x) . '%;';
                    $hotspot_styles .= ' top: ' . esc_attr($y) . '%;';
                    // Use clamp for responsive sizing - base size from settings but scales with viewport
                    $min_size = max(12, $hotspot_size * 0.6); // 60% of setting as minimum
                    $max_size = min(32, $hotspot_size * 1.2); // 120% of setting as maximum
                    $hotspot_styles .= ' width: clamp(' . $min_size . 'px, ' . ($hotspot_size * 0.15) . 'vw, ' . $hotspot_size . 'px);';
                    $hotspot_styles .= ' height: clamp(' . $min_size . 'px, ' . ($hotspot_size * 0.15) . 'vw, ' . $hotspot_size . 'px);';
                    $hotspot_styles .= ' background-color: ' . esc_attr($hotspot_color) . ';';
                    $hotspot_styles .= ' border: 2px solid white;';
                    $hotspot_styles .= ' transform: translate(-50%, -50%);';
                    $hotspot_styles .= ' display: flex;';
                    $hotspot_styles .= ' align-items: center;';
                    $hotspot_styles .= ' justify-content: center;';
                    $hotspot_styles .= ' color: white;';
                    $hotspot_styles .= ' font-size: clamp(8px, 2vw, 14px);';
                    $hotspot_styles .= ' font-weight: bold;';
                    $hotspot_styles .= ' box-shadow: 0 2px 8px rgba(0,0,0,0.3);';
                    $hotspot_styles .= ' z-index: 10;';
                    $hotspot_styles .= ' cursor: pointer;';
                    
                    if ($hotspot_style === 'circle' || $hotspot_style === 'pulse-dot') {
                        $hotspot_styles .= ' border-radius: 50%;';
                    }
                    ?>
                    
                    <div 
                        class="<?php echo esc_attr(implode(' ', $hotspot_classes)); ?>"
                        style="<?php echo $hotspot_styles; ?>"
                        data-id="<?php echo esc_attr($hotspot_id); ?>"
                        data-type="<?php echo esc_attr($type); ?>"
                        data-title="<?php echo esc_attr($title); ?>"
                        data-content="<?php echo esc_attr(wp_strip_all_tags($content)); ?>"
                        data-x="<?php echo esc_attr($x); ?>"
                        data-y="<?php echo esc_attr($y); ?>"
                        <?php if ($type === 'link' && $url): ?>
                            data-url="<?php echo esc_url($url); ?>"
                            data-link-target="<?php echo esc_attr($link_target); ?>"
                        <?php endif; ?>
                        aria-label="<?php echo esc_attr($title ?: __('Interactive hotspot', 'x-marks-the-spot-block-wp')); ?>"
                        role="button"
                        tabindex="0"
                    >
                        <?php if ($hotspot_style === 'plus'): ?>
                            +
                        <?php elseif ($hotspot_style === 'numbered'): ?>
                            <?php echo esc_html($index + 1); ?>
                        <?php endif; ?>
                    </div>
                <?php endforeach; ?>
            <?php endif; ?>
        </div>
    </div>
</div>]]></content>
  </file>
  <file name="package.json">
    <description>The AI assistant should only edit 'user_provided_block_name_slug', 'description' and resolve 'isDynamicVariant' in this file and ALWAYS INCLUDE IT. This file includes the necessary scripts for building, formatting, and linting the block code. Dependencies are managed at the workspace level via pnpm.</description>
    <content><![CDATA[{
    "name": "x-marks-the-spot",
    "version": "0.1.0",
    "description": "Transform static images into engaging, clickable experiences with interactive hotspots.",
    "author": "WordPress Telex",
    "license": "GPL-2.0-or-later",
    "main": "build/index.js",
    "scripts": {
        "build": "wp-scripts build --webpack-copy-php",
        "format": "wp-scripts format",
        "lint:css": "wp-scripts lint-style",
        "lint:js": "wp-scripts lint-js",
        "packages-update": "wp-scripts packages-update",
        "plugin-zip": "wp-scripts plugin-zip",
        "start": "wp-scripts start --blocks-manifest"
    }
}]]></content>
  </file>
</artefact>